import os.path
import argparse
import grammar_converter
import re

class Node:
    """
    Used for storing information about a non-terminal symbol. A node can have a maximum of two
    children because of the CNF of the grammar.
    It is possible though that there are multiple parses of a sentence. In this case information
    about an alternative child is stored in self.child1 or self.child2 (the parser will decide
    where according to the ambiguous rule).
    Either child1 is a terminal symbol passed as string, or both children are Nodes.
    """

    def __init__(self, symbol, child1, child2=None):
        self.symbol = symbol
        self.child1 = child1
        self.child2 = child2

    def __repr__(self):
        """
        :return: the string representation of a Node object.
        """
        return self.symbol


class Parser:
    """
    A CYK parser which is able to parse any grammar in CNF. The grammar can be read from a file or
    passed as a string. It either returns a string representation of the parse tree(s) or prints it
    to standard out.
    """

    def __init__(self, sentence):
        # sentence di ssini adalah file input
        # yang dalam dalam program sudah diprocess satu-satu perline
        # sehingga masukan harusnya berasal dari 
        """
        Creates a new parser object which will read in the grammar and transform it into CNF and
        then parse the given sentence with that grammar.
        :param grammar: the file path to the grammar/the string repr. of the grammar to read in
        :param sentence: the file path to the sentence/the string repr. of the sentence to read in
        """
        self.parse_table = None
        self.prods = {}
        self.grammar = grammar_converter.convert_grammar(grammar_converter.read_grammar("cfg_process.txt"))

        with open('cnf_from_indraf.txt', 'w') as cnf:
            for item in self.grammar:
                cnf.write("%s\n" % item)

        # self.__call__(sentence)
        with open(sentence) as inp:
	        self.inputline = [line.strip() for line in inp if line.strip()]
	        # this returns list

        incorrect = False
        for i in range(len(self.inputline)):
            #self.input = re.findall(r"[\w']+|[.,():=]", self.inputline[i])
            self.input = self.inputline[i].split()
            # print(self.input)
            self.parse()
            # self.print_tree2()
            start_symbol = self.grammar[0][0]
            final_nodes = [n for n in self.parse_table[-1][0] if n.symbol == start_symbol]
            # print(final_nodes)
            if not final_nodes:
            	print("Syntax error")
            	print ("  " + self.inputline[i])
            	incorrect = True
            	# break
        if not incorrect:
            print("Accepted")

    def parse(self):
        """
        Does the actual parsing according to the CYK algorithm. The parse table is stored in
        self.parse_table.
        """
        length = len(self.input)
        # self.parse_table[y][x] is the list of nodes in the x+1 cell of y+1 row in the table.
        # That cell covers the word below it and y more words after.
        self.parse_table = [[[] for x in range(length - y)] for y in range(length)]

        for i, word in enumerate(self.input):
            # Find out which non terminals can generate the terminals in the input string
            # and put them into the parse table. One terminal could be generated by multiple
            # non terminals, therefore the parse table will contain a list of non terminals.
            for rule in self.grammar:
                if f"'{word}'" == rule[1]:
                    self.parse_table[0][i].append(Node(rule[0], word))
        for words_to_consider in range(2, length + 1):
            for starting_cell in range(0, length - words_to_consider + 1):
                for left_size in range(1, words_to_consider):
                    right_size = words_to_consider - left_size

                    left_cell = self.parse_table[left_size - 1][starting_cell]
                    right_cell = self.parse_table[right_size - 1][starting_cell + left_size]

                    for rule in self.grammar:
                        left_nodes = [n for n in left_cell if n.symbol == rule[1]]
                        if left_nodes:
                            right_nodes = [n for n in right_cell if n.symbol == rule[2]]
                            self.parse_table[words_to_consider - 1][starting_cell].extend(
                                [Node(rule[0], left, right) for left in left_nodes for right in right_nodes]
                            )